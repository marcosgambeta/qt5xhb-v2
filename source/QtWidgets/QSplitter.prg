//
// Qt5xHb - Bindings libraries for Harbour/xHarbour and Qt Framework 5
//
// Copyright (c) 2026 Marcos Antonio Gambeta <marcosgambeta@outlook.com>
//

// DO NOT EDIT THIS FILE - the content was created using a source code generator

// clang-format off

#include <hbclass.ch>

#ifndef QT5XHB_NO_REQUESTS
REQUEST QByteArray
REQUEST QSize
REQUEST QSplitterHandle
REQUEST QWidget
#endif

CLASS QSplitter INHERIT QFrame

   METHOD new
   METHOD delete
   METHOD addWidget
   METHOD childrenCollapsible
   METHOD count
   METHOD getRange
   METHOD handle
   METHOD handleWidth
   METHOD indexOf
   METHOD insertWidget
   METHOD isCollapsible
   METHOD opaqueResize
   METHOD orientation
   METHOD refresh
   METHOD restoreState
   METHOD saveState
   METHOD setChildrenCollapsible
   METHOD setCollapsible
   METHOD setHandleWidth
   METHOD setOpaqueResize
   METHOD setOrientation
   METHOD setStretchFactor
   METHOD widget
   METHOD minimumSizeHint
   METHOD sizeHint

   METHOD onSplitterMoved

   DESTRUCTOR destroyObject

ENDCLASS

PROCEDURE destroyObject() CLASS QSplitter
   IF ::self_destruction
      ::delete()
   ENDIF
RETURN

// clang-format on

#pragma BEGINDUMP

#include <QtCore/Qt>

#ifndef __XHARBOUR__
#include <QtWidgets/QSplitter>
#endif

#include "qt5xhb_common.hpp"
#include "qt5xhb_macros.hpp"
#include "qt5xhb_utils.hpp"
#include "qt5xhb_events.hpp"
#include "qt5xhb_signals.hpp"

#ifdef __XHARBOUR__
#include <QtWidgets/QSplitter>
#endif

#define GET_PTR_FROM_SELF(p) auto p = qobject_cast<QSplitter *>(Qt5xHb::getQObjectPointerFromSelfItem())

HB_FUNC_STATIC(QSPLITTER_NEW)
{
  if (ISBETWEEN(0, 1) && ISQWIDGETORNIL(1)) {
    // QSplitter(QWidget *parent = nullptr)
    auto obj = new QSplitter(OPQWIDGET(1, nullptr));
    Qt5xHb::returnNewObject(obj, false);

  } else if (ISBETWEEN(1, 2) && HB_ISNUM(1) && ISQWIDGETORNIL(2)) {
    // QSplitter(Qt::Orientation orientation, QWidget *parent = nullptr)
    auto obj = new QSplitter(PQT_ORIENTATION(1), OPQWIDGET(2, nullptr));
    Qt5xHb::returnNewObject(obj, false);

  } else {
    THROW_ERROR_3012();
  }
}

HB_FUNC_STATIC(QSPLITTER_DELETE)
{
  GET_PTR_FROM_SELF(obj);
  DELETE_QOBJECT(obj);
  RETURN_SELF();
}

// void addWidget(QWidget *widget)
HB_FUNC_STATIC(QSPLITTER_ADDWIDGET)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && ISQWIDGET(1)) {
#endif
      obj->addWidget(PQWIDGET(1));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// bool childrenCollapsible() const
HB_FUNC_STATIC(QSPLITTER_CHILDRENCOLLAPSIBLE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RBOOL(obj->childrenCollapsible());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// int count() const
HB_FUNC_STATIC(QSPLITTER_COUNT)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RINT(obj->count());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// void getRange(int index, int *min, int *max) const
HB_FUNC_STATIC(QSPLITTER_GETRANGE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(3) && HB_ISNUM(1) && HB_ISNUM(2) && HB_ISNUM(3)) {
#endif
      int par2;
      int par3;
      obj->getRange(PINT(1), &par2, &par3);
      hb_storni(par2, 2);
      hb_storni(par3, 3);
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// QSplitterHandle *handle(int index) const
HB_FUNC_STATIC(QSPLITTER_HANDLE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && HB_ISNUM(1)) {
#endif
      auto ptr = obj->handle(PINT(1));
      Qt5xHb::createReturnQWidgetClass(ptr, "QSPLITTERHANDLE");
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// int handleWidth() const
HB_FUNC_STATIC(QSPLITTER_HANDLEWIDTH)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RINT(obj->handleWidth());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// int indexOf(QWidget *widget) const
HB_FUNC_STATIC(QSPLITTER_INDEXOF)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && ISQWIDGET(1)) {
#endif
      RINT(obj->indexOf(PQWIDGET(1)));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// void insertWidget(int index, QWidget *widget)
HB_FUNC_STATIC(QSPLITTER_INSERTWIDGET)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(2) && HB_ISNUM(1) && ISQWIDGET(2)) {
#endif
      obj->insertWidget(PINT(1), PQWIDGET(2));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// bool isCollapsible(int index) const
HB_FUNC_STATIC(QSPLITTER_ISCOLLAPSIBLE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && HB_ISNUM(1)) {
#endif
      RBOOL(obj->isCollapsible(PINT(1)));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// bool opaqueResize() const
HB_FUNC_STATIC(QSPLITTER_OPAQUERESIZE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RBOOL(obj->opaqueResize());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// Qt::Orientation orientation() const
HB_FUNC_STATIC(QSPLITTER_ORIENTATION)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RENUM(obj->orientation());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// void refresh()
HB_FUNC_STATIC(QSPLITTER_REFRESH)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      obj->refresh();
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// bool restoreState(const QByteArray &state)
HB_FUNC_STATIC(QSPLITTER_RESTORESTATE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && ISQBYTEARRAY(1)) {
#endif
      RBOOL(obj->restoreState(*PQBYTEARRAY(1)));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// QByteArray saveState() const
HB_FUNC_STATIC(QSPLITTER_SAVESTATE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RQBYTEARRAY(obj->saveState());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// void setChildrenCollapsible(bool)
HB_FUNC_STATIC(QSPLITTER_SETCHILDRENCOLLAPSIBLE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && HB_ISLOG(1)) {
#endif
      obj->setChildrenCollapsible(PBOOL(1));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// void setCollapsible(int index, bool collapse)
HB_FUNC_STATIC(QSPLITTER_SETCOLLAPSIBLE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(2) && HB_ISNUM(1) && HB_ISLOG(2)) {
#endif
      obj->setCollapsible(PINT(1), PBOOL(2));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// void setHandleWidth(int)
HB_FUNC_STATIC(QSPLITTER_SETHANDLEWIDTH)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && HB_ISNUM(1)) {
#endif
      obj->setHandleWidth(PINT(1));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// void setOpaqueResize(bool opaque = true)
HB_FUNC_STATIC(QSPLITTER_SETOPAQUERESIZE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISBETWEEN(0, 1) && ISLOGORNIL(1)) {
#endif
      obj->setOpaqueResize(OPBOOL(1, true));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// void setOrientation(Qt::Orientation)
HB_FUNC_STATIC(QSPLITTER_SETORIENTATION)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && HB_ISNUM(1)) {
#endif
      obj->setOrientation(PQT_ORIENTATION(1));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// void setStretchFactor(int index, int stretch)
HB_FUNC_STATIC(QSPLITTER_SETSTRETCHFACTOR)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(2) && HB_ISNUM(1) && HB_ISNUM(2)) {
#endif
      obj->setStretchFactor(PINT(1), PINT(2));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// QWidget *widget(int index) const
HB_FUNC_STATIC(QSPLITTER_WIDGET)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && HB_ISNUM(1)) {
#endif
      auto ptr = obj->widget(PINT(1));
      Qt5xHb::createReturnQWidgetClass(ptr, "QWIDGET");
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// virtual QSize minimumSizeHint() const
HB_FUNC_STATIC(QSPLITTER_MINIMUMSIZEHINT)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RQSIZE(obj->minimumSizeHint());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// virtual QSize sizeHint() const
HB_FUNC_STATIC(QSPLITTER_SIZEHINT)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RQSIZE(obj->sizeHint());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// void splitterMoved(int pos, int index)
HB_FUNC_STATIC(QSPLITTER_ONSPLITTERMOVED)
{
  GET_PTR_FROM_SELF(sender);

  auto result = false;

  if (sender != nullptr) {
    auto indexOfSignal = sender->metaObject()->indexOfSignal("splitterMoved(int,int)");
    auto indexOfCodeBlock = -1;

    if (ISNUMPAR(1) && ISBLOCKORSYMBOL(1)) {
      if (Qt5xHb::Signals_connection(sender, indexOfSignal, indexOfCodeBlock)) {
        auto connection =
            QObject::connect(sender, &QSplitter::splitterMoved, [sender, indexOfCodeBlock](int arg1, int arg2) {
              auto cb = Qt5xHb::Signals_return_codeblock(indexOfCodeBlock);

              if (cb != nullptr) {
                auto pSender = Qt5xHb::Signals_return_qobject(sender, "QSPLITTER");
                auto pArg1 = hb_itemPutNI(nullptr, arg1);
                auto pArg2 = hb_itemPutNI(nullptr, arg2);
                hb_vmEvalBlockV(cb, 3, pSender, pArg1, pArg2);
                hb_itemRelease(pSender);
                hb_itemRelease(pArg1);
                hb_itemRelease(pArg2);
              }
            });
        Qt5xHb::Signals_store_connection(indexOfCodeBlock, connection);
        result = true;
      }
    } else if (ISNUMPAR(0)) {
      Qt5xHb::Signals_disconnection(sender, indexOfSignal);
      QObject::disconnect(Qt5xHb::Signals_get_connection(sender, indexOfSignal));
      result = true;
    } else {
      THROW_ERROR_3012();
    }
  }

  hb_retl(result);
}

#pragma ENDDUMP
