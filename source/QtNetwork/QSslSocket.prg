//
// Qt5xHb - Bindings libraries for Harbour/xHarbour and Qt Framework 5
//
// Copyright (c) 2026 Marcos Antonio Gambeta <marcosgambeta@outlook.com>
//

// DO NOT EDIT THIS FILE - the content was created using a source code generator

// clang-format off

#include <hbclass.ch>

#ifndef QT5XHB_NO_REQUESTS
REQUEST QSslCertificate
REQUEST QSslCipher
REQUEST QSslConfiguration
REQUEST QSslError
REQUEST QSslKey
REQUEST QVariant
#endif

CLASS QSslSocket INHERIT QTcpSocket

   METHOD new
   METHOD delete
   METHOD resume
   METHOD connectToHostEncrypted
   METHOD setSocketDescriptor
   METHOD connectToHost
   METHOD disconnectFromHost
   METHOD setSocketOption
   METHOD socketOption
   METHOD mode
   METHOD isEncrypted
   METHOD protocol
   METHOD setProtocol
   METHOD peerVerifyMode
   METHOD setPeerVerifyMode
   METHOD peerVerifyDepth
   METHOD setPeerVerifyDepth
   METHOD peerVerifyName
   METHOD setPeerVerifyName
   METHOD bytesAvailable
   METHOD bytesToWrite
   METHOD canReadLine
   METHOD close
   METHOD atEnd
   METHOD flush
   METHOD abort
   METHOD setReadBufferSize
   METHOD encryptedBytesAvailable
   METHOD encryptedBytesToWrite
   METHOD sslConfiguration
   METHOD setSslConfiguration
   METHOD setLocalCertificateChain
   METHOD localCertificateChain
   METHOD setLocalCertificate
   METHOD localCertificate
   METHOD peerCertificate
   METHOD peerCertificateChain
   METHOD sessionCipher
   METHOD sessionProtocol
   METHOD setPrivateKey
   METHOD privateKey
   METHOD ciphers
   METHOD setCiphers
   METHOD setDefaultCiphers
   METHOD defaultCiphers
   METHOD supportedCiphers
   METHOD addCaCertificates
   METHOD addCaCertificate
   METHOD setCaCertificates
   METHOD caCertificates
   METHOD addDefaultCaCertificate
   METHOD addDefaultCaCertificates
   METHOD setDefaultCaCertificates
   METHOD defaultCaCertificates
   METHOD systemCaCertificates
   METHOD waitForConnected
   METHOD waitForEncrypted
   METHOD waitForReadyRead
   METHOD waitForBytesWritten
   METHOD waitForDisconnected
   METHOD sslErrors
   METHOD supportsSsl
   METHOD sslLibraryVersionNumber
   METHOD sslLibraryVersionString
   METHOD sslLibraryBuildVersionNumber
   METHOD sslLibraryBuildVersionString
   METHOD ignoreSslErrors
   METHOD startClientEncryption
   METHOD startServerEncryption

   METHOD onEncrypted
   METHOD onEncryptedBytesWritten
   METHOD onModeChanged
   METHOD onPeerVerifyError
   METHOD onPreSharedKeyAuthenticationRequired
   METHOD onSslErrors

   DESTRUCTOR destroyObject

ENDCLASS

PROCEDURE destroyObject() CLASS QSslSocket
   IF ::self_destruction
      ::delete()
   ENDIF
RETURN

// clang-format on

#pragma BEGINDUMP

#include <QtCore/Qt>

#ifndef __XHARBOUR__
#include <QtNetwork/QSslSocket>
#endif

#include "qt5xhb_common.hpp"
#include "qt5xhb_macros.hpp"
#include "qt5xhb_utils.hpp"
#include "qt5xhb_events.hpp"
#include "qt5xhb_signals.hpp"

#ifdef __XHARBOUR__
#include <QtNetwork/QSslSocket>
#endif

#include <QtNetwork/QSslCipher>
#include <QtNetwork/QSslConfiguration>
#include <QtNetwork/QSslKey>
#include <QtNetwork/QSslPreSharedKeyAuthenticator>

#define GET_PTR_FROM_SELF(p) auto p = qobject_cast<QSslSocket *>(Qt5xHb::getQObjectPointerFromSelfItem())

// QSslSocket(QObject *parent = nullptr)
HB_FUNC_STATIC(QSSLSOCKET_NEW)
{
  if (ISBETWEEN(0, 1) && ISQOBJECTORNIL(1)) {
    auto obj = new QSslSocket(OPQOBJECT(1, nullptr));
    Qt5xHb::returnNewObject(obj, false);
  } else {
    THROW_ERROR_3012();
  }
}

// ~QSslSocket()
HB_FUNC_STATIC(QSSLSOCKET_DELETE)
{
  GET_PTR_FROM_SELF(obj);
  DELETE_QOBJECT(obj);
  RETURN_SELF();
}

// void resume() Q_DECL_OVERRIDE
HB_FUNC_STATIC(QSSLSOCKET_RESUME)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      obj->resume();
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

HB_FUNC_STATIC(QSSLSOCKET_CONNECTTOHOSTENCRYPTED)
{
  if (ISBETWEEN(2, 4) && HB_ISCHAR(1) && HB_ISNUM(2) && ISNUMORNIL(3) && ISNUMORNIL(4)) {
    // void connectToHostEncrypted(const QString &hostName, quint16 port, QIODevice::OpenMode mode =
    // QIODevice::ReadWrite, QAbstractSocket::NetworkLayerProtocol protocol = QAbstractSocket::AnyIPProtocol)
    GET_PTR_FROM_SELF(obj);

    if (obj != nullptr) {
      obj->connectToHostEncrypted(PQSTRING(1), PQUINT16(2), HB_ISNIL(3) ? QIODevice::ReadWrite : PQIODEVICE_OPENMODE(3),
                                  HB_ISNIL(4) ? QAbstractSocket::AnyIPProtocol
                                              : PQABSTRACTSOCKET_NETWORKLAYERPROTOCOL(4));
    }

    RETURN_SELF();
  } else if (ISBETWEEN(3, 5) && HB_ISCHAR(1) && HB_ISNUM(2) && HB_ISCHAR(3) && ISNUMORNIL(4) && ISNUMORNIL(5)) {
    // void connectToHostEncrypted(const QString &hostName, quint16 port, const QString &sslPeerName,
    // QIODevice::OpenMode mode = QIODevice::ReadWrite, QAbstractSocket::NetworkLayerProtocol protocol =
    // QAbstractSocket::AnyIPProtocol)
    GET_PTR_FROM_SELF(obj);

    if (obj != nullptr) {
      obj->connectToHostEncrypted(
          PQSTRING(1), PQUINT16(2), PQSTRING(3), HB_ISNIL(4) ? QIODevice::ReadWrite : PQIODEVICE_OPENMODE(4),
          HB_ISNIL(5) ? QAbstractSocket::AnyIPProtocol : PQABSTRACTSOCKET_NETWORKLAYERPROTOCOL(5));
    }

    RETURN_SELF();
  } else {
    THROW_ERROR_3012();
  }
}

// bool setSocketDescriptor(qintptr socketDescriptor, QAbstractSocket::SocketState state =
// QAbstractSocket::ConnectedState, QIODevice::OpenMode openMode = QIODevice::ReadWrite) Q_DECL_OVERRIDE
HB_FUNC_STATIC(QSSLSOCKET_SETSOCKETDESCRIPTOR)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISBETWEEN(1, 3) && HB_ISNUM(1) && ISNUMORNIL(2) && ISNUMORNIL(3)) {
#endif
      RBOOL(obj->setSocketDescriptor(PQINTPTR(1),
                                     HB_ISNIL(2) ? QAbstractSocket::ConnectedState : PQABSTRACTSOCKET_SOCKETSTATE(2),
                                     HB_ISNIL(3) ? QIODevice::ReadWrite : PQIODEVICE_OPENMODE(3)));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// void connectToHost(const QString &hostName, quint16 port, QIODevice::OpenMode openMode = QIODevice::ReadWrite,
// QAbstractSocket::NetworkLayerProtocol protocol = QAbstractSocket::AnyIPProtocol) Q_DECL_OVERRIDE
HB_FUNC_STATIC(QSSLSOCKET_CONNECTTOHOST)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISBETWEEN(2, 4) && HB_ISCHAR(1) && HB_ISNUM(2) && ISNUMORNIL(3) && ISNUMORNIL(4)) {
#endif
      obj->connectToHost(PQSTRING(1), PQUINT16(2), HB_ISNIL(3) ? QIODevice::ReadWrite : PQIODEVICE_OPENMODE(3),
                         HB_ISNIL(4) ? QAbstractSocket::AnyIPProtocol : PQABSTRACTSOCKET_NETWORKLAYERPROTOCOL(4));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// void disconnectFromHost() Q_DECL_OVERRIDE
HB_FUNC_STATIC(QSSLSOCKET_DISCONNECTFROMHOST)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      obj->disconnectFromHost();
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// virtual void setSocketOption(QAbstractSocket::SocketOption option, const QVariant &value) Q_DECL_OVERRIDE
HB_FUNC_STATIC(QSSLSOCKET_SETSOCKETOPTION)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(2) && HB_ISNUM(1) && ISQVARIANT(2)) {
#endif
      obj->setSocketOption(PQABSTRACTSOCKET_SOCKETOPTION(1), *PQVARIANT(2));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// virtual QVariant socketOption(QAbstractSocket::SocketOption option) Q_DECL_OVERRIDE
HB_FUNC_STATIC(QSSLSOCKET_SOCKETOPTION)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && HB_ISNUM(1)) {
#endif
      RQVARIANT(obj->socketOption(PQABSTRACTSOCKET_SOCKETOPTION(1)));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// QSslSocket::SslMode mode() const
HB_FUNC_STATIC(QSSLSOCKET_MODE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RENUM(obj->mode());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// bool isEncrypted() const
HB_FUNC_STATIC(QSSLSOCKET_ISENCRYPTED)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RBOOL(obj->isEncrypted());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// QSsl::SslProtocol protocol() const
HB_FUNC_STATIC(QSSLSOCKET_PROTOCOL)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RENUM(obj->protocol());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// void setProtocol(QSsl::SslProtocol protocol)
HB_FUNC_STATIC(QSSLSOCKET_SETPROTOCOL)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && HB_ISNUM(1)) {
#endif
      obj->setProtocol(PQSSL_SSLPROTOCOL(1));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// QSslSocket::PeerVerifyMode peerVerifyMode() const
HB_FUNC_STATIC(QSSLSOCKET_PEERVERIFYMODE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RENUM(obj->peerVerifyMode());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// void setPeerVerifyMode(QSslSocket::PeerVerifyMode mode)
HB_FUNC_STATIC(QSSLSOCKET_SETPEERVERIFYMODE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && HB_ISNUM(1)) {
#endif
      obj->setPeerVerifyMode(PQSSLSOCKET_PEERVERIFYMODE(1));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// int peerVerifyDepth() const
HB_FUNC_STATIC(QSSLSOCKET_PEERVERIFYDEPTH)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RINT(obj->peerVerifyDepth());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// void setPeerVerifyDepth(int depth)
HB_FUNC_STATIC(QSSLSOCKET_SETPEERVERIFYDEPTH)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && HB_ISNUM(1)) {
#endif
      obj->setPeerVerifyDepth(PINT(1));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// QString peerVerifyName() const
HB_FUNC_STATIC(QSSLSOCKET_PEERVERIFYNAME)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RQSTRING(obj->peerVerifyName());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// void setPeerVerifyName(const QString &hostName)
HB_FUNC_STATIC(QSSLSOCKET_SETPEERVERIFYNAME)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && HB_ISCHAR(1)) {
#endif
      obj->setPeerVerifyName(PQSTRING(1));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// qint64 bytesAvailable() const Q_DECL_OVERRIDE
HB_FUNC_STATIC(QSSLSOCKET_BYTESAVAILABLE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RQINT64(obj->bytesAvailable());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// qint64 bytesToWrite() const Q_DECL_OVERRIDE
HB_FUNC_STATIC(QSSLSOCKET_BYTESTOWRITE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RQINT64(obj->bytesToWrite());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// bool canReadLine() const Q_DECL_OVERRIDE
HB_FUNC_STATIC(QSSLSOCKET_CANREADLINE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RBOOL(obj->canReadLine());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// void close() Q_DECL_OVERRIDE
HB_FUNC_STATIC(QSSLSOCKET_CLOSE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      obj->close();
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// bool atEnd() const Q_DECL_OVERRIDE
HB_FUNC_STATIC(QSSLSOCKET_ATEND)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RBOOL(obj->atEnd());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// bool flush()
HB_FUNC_STATIC(QSSLSOCKET_FLUSH)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RBOOL(obj->flush());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// void abort()
HB_FUNC_STATIC(QSSLSOCKET_ABORT)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      obj->abort();
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// void setReadBufferSize(qint64 size) Q_DECL_OVERRIDE
HB_FUNC_STATIC(QSSLSOCKET_SETREADBUFFERSIZE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && HB_ISNUM(1)) {
#endif
      obj->setReadBufferSize(PQINT64(1));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// qint64 encryptedBytesAvailable() const
HB_FUNC_STATIC(QSSLSOCKET_ENCRYPTEDBYTESAVAILABLE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RQINT64(obj->encryptedBytesAvailable());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// qint64 encryptedBytesToWrite() const
HB_FUNC_STATIC(QSSLSOCKET_ENCRYPTEDBYTESTOWRITE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RQINT64(obj->encryptedBytesToWrite());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// QSslConfiguration sslConfiguration() const
HB_FUNC_STATIC(QSSLSOCKET_SSLCONFIGURATION)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RQSSLCONFIGURATION(obj->sslConfiguration());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// void setSslConfiguration(const QSslConfiguration &config)
HB_FUNC_STATIC(QSSLSOCKET_SETSSLCONFIGURATION)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && ISQSSLCONFIGURATION(1)) {
#endif
      obj->setSslConfiguration(*PQSSLCONFIGURATION(1));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// void setLocalCertificateChain(const QList<QSslCertificate> &localChain)
HB_FUNC_STATIC(QSSLSOCKET_SETLOCALCERTIFICATECHAIN)
{
#if (QT_VERSION >= QT_VERSION_CHECK(5, 1, 0))
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && HB_ISARRAY(1)) {
#endif
      QList<QSslCertificate> par1;
      auto aList1 = hb_param(1, HB_IT_ARRAY);
      int nLen1 = hb_arrayLen(aList1);
      for (auto i1 = 0; i1 < nLen1; i1++) {
        par1 << *static_cast<QSslCertificate *>(
            hb_itemGetPtr(hb_objSendMsg(hb_arrayGetItemPtr(aList1, i1 + 1), "POINTER", 0)));
      }
      obj->setLocalCertificateChain(par1);
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
#endif
}

// QList<QSslCertificate> localCertificateChain() const
HB_FUNC_STATIC(QSSLSOCKET_LOCALCERTIFICATECHAIN)
{
#if (QT_VERSION >= QT_VERSION_CHECK(5, 1, 0))
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      auto list = obj->localCertificateChain();
      auto pDynSym = hb_dynsymFindName("QSSLCERTIFICATE");
      auto pArray = hb_itemArrayNew(0);
      if (pDynSym != nullptr) {
        for (const auto &item : list) {
          hb_vmPushDynSym(pDynSym);
          hb_vmPushNil();
          hb_vmDo(0);
          auto pObject = hb_itemNew(nullptr);
          hb_itemCopy(pObject, hb_stackReturnItem());
          auto pItem = hb_itemPutPtr(nullptr, new QSslCertificate(item));
          hb_objSendMsg(pObject, "_POINTER", 1, pItem);
          hb_itemRelease(pItem);
          auto pDestroy = hb_itemPutL(nullptr, true);
          hb_objSendMsg(pObject, "_SELF_DESTRUCTION", 1, pDestroy);
          hb_itemRelease(pDestroy);
          hb_arrayAddForward(pArray, pObject);
          hb_itemRelease(pObject);
        }
      } else {
        hb_errRT_BASE(EG_NOFUNC, 1001, nullptr, "QSSLCERTIFICATE", HB_ERR_ARGS_BASEPARAMS);
      }
      hb_itemReturnRelease(pArray);
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
#endif
}

HB_FUNC_STATIC(QSSLSOCKET_SETLOCALCERTIFICATE)
{
  if (ISNUMPAR(1) && ISQSSLCERTIFICATE(1)) {
    // void setLocalCertificate(const QSslCertificate &certificate)
    GET_PTR_FROM_SELF(obj);

    if (obj != nullptr) {
      obj->setLocalCertificate(*PQSSLCERTIFICATE(1));
    }

    RETURN_SELF();
  } else if (ISBETWEEN(1, 2) && HB_ISCHAR(1) && ISNUMORNIL(2)) {
    // void setLocalCertificate(const QString &fileName, QSsl::EncodingFormat format = QSsl::Pem)
    GET_PTR_FROM_SELF(obj);

    if (obj != nullptr) {
      obj->setLocalCertificate(PQSTRING(1), HB_ISNIL(2) ? QSsl::Pem : PQSSL_ENCODINGFORMAT(2));
    }

    RETURN_SELF();
  } else {
    THROW_ERROR_3012();
  }
}

// QSslCertificate localCertificate() const
HB_FUNC_STATIC(QSSLSOCKET_LOCALCERTIFICATE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RQSSLCERTIFICATE(obj->localCertificate());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// QSslCertificate peerCertificate() const
HB_FUNC_STATIC(QSSLSOCKET_PEERCERTIFICATE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RQSSLCERTIFICATE(obj->peerCertificate());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// QList<QSslCertificate> peerCertificateChain() const
HB_FUNC_STATIC(QSSLSOCKET_PEERCERTIFICATECHAIN)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      auto list = obj->peerCertificateChain();
      auto pDynSym = hb_dynsymFindName("QSSLCERTIFICATE");
      auto pArray = hb_itemArrayNew(0);
      if (pDynSym != nullptr) {
        for (const auto &item : list) {
          hb_vmPushDynSym(pDynSym);
          hb_vmPushNil();
          hb_vmDo(0);
          auto pObject = hb_itemNew(nullptr);
          hb_itemCopy(pObject, hb_stackReturnItem());
          auto pItem = hb_itemPutPtr(nullptr, new QSslCertificate(item));
          hb_objSendMsg(pObject, "_POINTER", 1, pItem);
          hb_itemRelease(pItem);
          auto pDestroy = hb_itemPutL(nullptr, true);
          hb_objSendMsg(pObject, "_SELF_DESTRUCTION", 1, pDestroy);
          hb_itemRelease(pDestroy);
          hb_arrayAddForward(pArray, pObject);
          hb_itemRelease(pObject);
        }
      } else {
        hb_errRT_BASE(EG_NOFUNC, 1001, nullptr, "QSSLCERTIFICATE", HB_ERR_ARGS_BASEPARAMS);
      }
      hb_itemReturnRelease(pArray);
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// QSslCipher sessionCipher() const
HB_FUNC_STATIC(QSSLSOCKET_SESSIONCIPHER)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RQSSLCIPHER(obj->sessionCipher());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// QSsl::SslProtocol sessionProtocol() const
HB_FUNC_STATIC(QSSLSOCKET_SESSIONPROTOCOL)
{
#if (QT_VERSION >= QT_VERSION_CHECK(5, 4, 0))
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RENUM(obj->sessionProtocol());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
#endif
}

HB_FUNC_STATIC(QSSLSOCKET_SETPRIVATEKEY)
{
  if (ISNUMPAR(1) && ISQSSLKEY(1)) {
    // void setPrivateKey(const QSslKey &key)
    GET_PTR_FROM_SELF(obj);

    if (obj != nullptr) {
      obj->setPrivateKey(*PQSSLKEY(1));
    }

    RETURN_SELF();
  } else if (ISBETWEEN(1, 4) && HB_ISCHAR(1) && ISNUMORNIL(2) && ISNUMORNIL(3) && ISQBYTEARRAYORNIL(4)) {
    // void setPrivateKey(const QString &fileName, QSsl::KeyAlgorithm algorithm = QSsl::Rsa, QSsl::EncodingFormat format
    // = QSsl::Pem, const QByteArray &passPhrase = QByteArray())
    GET_PTR_FROM_SELF(obj);

    if (obj != nullptr) {
      obj->setPrivateKey(PQSTRING(1), HB_ISNIL(2) ? QSsl::Rsa : PQSSL_KEYALGORITHM(2),
                         HB_ISNIL(3) ? QSsl::Pem : PQSSL_ENCODINGFORMAT(3),
                         HB_ISNIL(4) ? QByteArray() : *PQBYTEARRAY(4));
    }

    RETURN_SELF();
  } else {
    THROW_ERROR_3012();
  }
}

// QSslKey privateKey() const
HB_FUNC_STATIC(QSSLSOCKET_PRIVATEKEY)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RQSSLKEY(obj->privateKey());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// QList<QSslCipher> ciphers() const
HB_FUNC_STATIC(QSSLSOCKET_CIPHERS)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      auto list = obj->ciphers();
      auto pDynSym = hb_dynsymFindName("QSSLCIPHER");
      auto pArray = hb_itemArrayNew(0);
      if (pDynSym != nullptr) {
        for (const auto &item : list) {
          hb_vmPushDynSym(pDynSym);
          hb_vmPushNil();
          hb_vmDo(0);
          auto pObject = hb_itemNew(nullptr);
          hb_itemCopy(pObject, hb_stackReturnItem());
          auto pItem = hb_itemPutPtr(nullptr, new QSslCipher(item));
          hb_objSendMsg(pObject, "_POINTER", 1, pItem);
          hb_itemRelease(pItem);
          auto pDestroy = hb_itemPutL(nullptr, true);
          hb_objSendMsg(pObject, "_SELF_DESTRUCTION", 1, pDestroy);
          hb_itemRelease(pDestroy);
          hb_arrayAddForward(pArray, pObject);
          hb_itemRelease(pObject);
        }
      } else {
        hb_errRT_BASE(EG_NOFUNC, 1001, nullptr, "QSSLCIPHER", HB_ERR_ARGS_BASEPARAMS);
      }
      hb_itemReturnRelease(pArray);
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

HB_FUNC_STATIC(QSSLSOCKET_SETCIPHERS)
{
  if (ISNUMPAR(1) && HB_ISARRAY(1)) {
    // void setCiphers(const QList<QSslCipher> &ciphers)
    GET_PTR_FROM_SELF(obj);

    if (obj != nullptr) {
      QList<QSslCipher> par1;
      auto aList1 = hb_param(1, HB_IT_ARRAY);
      int nLen1 = hb_arrayLen(aList1);
      for (auto i1 = 0; i1 < nLen1; i1++) {
        par1 << *static_cast<QSslCipher *>(
            hb_itemGetPtr(hb_objSendMsg(hb_arrayGetItemPtr(aList1, i1 + 1), "POINTER", 0)));
      }
      obj->setCiphers(par1);
    }

    RETURN_SELF();
  } else if (ISNUMPAR(1) && HB_ISCHAR(1)) {
    // void setCiphers(const QString &ciphers)
    GET_PTR_FROM_SELF(obj);

    if (obj != nullptr) {
      obj->setCiphers(PQSTRING(1));
    }

    RETURN_SELF();
  } else {
    THROW_ERROR_3012();
  }
}

// static void setDefaultCiphers(const QList<QSslCipher> &ciphers)
HB_FUNC_STATIC(QSSLSOCKET_SETDEFAULTCIPHERS)
{
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  if (ISNUMPAR(1) && HB_ISARRAY(1)) {
#endif
    QList<QSslCipher> par1;
    auto aList1 = hb_param(1, HB_IT_ARRAY);
    int nLen1 = hb_arrayLen(aList1);
    for (auto i1 = 0; i1 < nLen1; i1++) {
      par1 << *static_cast<QSslCipher *>(
          hb_itemGetPtr(hb_objSendMsg(hb_arrayGetItemPtr(aList1, i1 + 1), "POINTER", 0)));
    }
    QSslSocket::setDefaultCiphers(par1);
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  } else {
    THROW_ERROR_3012();
  }
#endif

  RETURN_SELF();
}

// static QList<QSslCipher> defaultCiphers()
HB_FUNC_STATIC(QSSLSOCKET_DEFAULTCIPHERS)
{
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  if (ISNUMPAR(0)) {
#endif
    auto list = QSslSocket::defaultCiphers();
    auto pDynSym = hb_dynsymFindName("QSSLCIPHER");
    auto pArray = hb_itemArrayNew(0);
    if (pDynSym != nullptr) {
      for (const auto &item : list) {
        hb_vmPushDynSym(pDynSym);
        hb_vmPushNil();
        hb_vmDo(0);
        auto pObject = hb_itemNew(nullptr);
        hb_itemCopy(pObject, hb_stackReturnItem());
        auto pItem = hb_itemPutPtr(nullptr, new QSslCipher(item));
        hb_objSendMsg(pObject, "_POINTER", 1, pItem);
        hb_itemRelease(pItem);
        auto pDestroy = hb_itemPutL(nullptr, true);
        hb_objSendMsg(pObject, "_SELF_DESTRUCTION", 1, pDestroy);
        hb_itemRelease(pDestroy);
        hb_arrayAddForward(pArray, pObject);
        hb_itemRelease(pObject);
      }
    } else {
      hb_errRT_BASE(EG_NOFUNC, 1001, nullptr, "QSSLCIPHER", HB_ERR_ARGS_BASEPARAMS);
    }
    hb_itemReturnRelease(pArray);
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  } else {
    THROW_ERROR_3012();
  }
#endif
}

// static QList<QSslCipher> supportedCiphers()
HB_FUNC_STATIC(QSSLSOCKET_SUPPORTEDCIPHERS)
{
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  if (ISNUMPAR(0)) {
#endif
    auto list = QSslSocket::supportedCiphers();
    auto pDynSym = hb_dynsymFindName("QSSLCIPHER");
    auto pArray = hb_itemArrayNew(0);
    if (pDynSym != nullptr) {
      for (const auto &item : list) {
        hb_vmPushDynSym(pDynSym);
        hb_vmPushNil();
        hb_vmDo(0);
        auto pObject = hb_itemNew(nullptr);
        hb_itemCopy(pObject, hb_stackReturnItem());
        auto pItem = hb_itemPutPtr(nullptr, new QSslCipher(item));
        hb_objSendMsg(pObject, "_POINTER", 1, pItem);
        hb_itemRelease(pItem);
        auto pDestroy = hb_itemPutL(nullptr, true);
        hb_objSendMsg(pObject, "_SELF_DESTRUCTION", 1, pDestroy);
        hb_itemRelease(pDestroy);
        hb_arrayAddForward(pArray, pObject);
        hb_itemRelease(pObject);
      }
    } else {
      hb_errRT_BASE(EG_NOFUNC, 1001, nullptr, "QSSLCIPHER", HB_ERR_ARGS_BASEPARAMS);
    }
    hb_itemReturnRelease(pArray);
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  } else {
    THROW_ERROR_3012();
  }
#endif
}

HB_FUNC_STATIC(QSSLSOCKET_ADDCACERTIFICATES)
{
  if (ISBETWEEN(1, 3) && HB_ISCHAR(1) && ISNUMORNIL(2) && ISNUMORNIL(3)) {
    // bool addCaCertificates(const QString &path, QSsl::EncodingFormat format = QSsl::Pem, QRegExp::PatternSyntax
    // syntax = QRegExp::FixedString)
    GET_PTR_FROM_SELF(obj);

    if (obj != nullptr) {
      RBOOL(obj->addCaCertificates(PQSTRING(1), HB_ISNIL(2) ? QSsl::Pem : PQSSL_ENCODINGFORMAT(2),
                                   HB_ISNIL(3) ? QRegExp::FixedString : PQREGEXP_PATTERNSYNTAX(3)));
    }
  } else if (ISNUMPAR(1) && HB_ISARRAY(1)) {
    // void addCaCertificates(const QList<QSslCertificate> &certificates)
    GET_PTR_FROM_SELF(obj);

    if (obj != nullptr) {
      QList<QSslCertificate> par1;
      auto aList1 = hb_param(1, HB_IT_ARRAY);
      int nLen1 = hb_arrayLen(aList1);
      for (auto i1 = 0; i1 < nLen1; i1++) {
        par1 << *static_cast<QSslCertificate *>(
            hb_itemGetPtr(hb_objSendMsg(hb_arrayGetItemPtr(aList1, i1 + 1), "POINTER", 0)));
      }
      obj->addCaCertificates(par1);
    }

    RETURN_SELF();
  } else {
    THROW_ERROR_3012();
  }
}

// void addCaCertificate(const QSslCertificate &certificate)
HB_FUNC_STATIC(QSSLSOCKET_ADDCACERTIFICATE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && ISQSSLCERTIFICATE(1)) {
#endif
      obj->addCaCertificate(*PQSSLCERTIFICATE(1));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// void setCaCertificates(const QList<QSslCertificate> &certificates)
HB_FUNC_STATIC(QSSLSOCKET_SETCACERTIFICATES)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && HB_ISARRAY(1)) {
#endif
      QList<QSslCertificate> par1;
      auto aList1 = hb_param(1, HB_IT_ARRAY);
      int nLen1 = hb_arrayLen(aList1);
      for (auto i1 = 0; i1 < nLen1; i1++) {
        par1 << *static_cast<QSslCertificate *>(
            hb_itemGetPtr(hb_objSendMsg(hb_arrayGetItemPtr(aList1, i1 + 1), "POINTER", 0)));
      }
      obj->setCaCertificates(par1);
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// QList<QSslCertificate> caCertificates() const
HB_FUNC_STATIC(QSSLSOCKET_CACERTIFICATES)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      auto list = obj->caCertificates();
      auto pDynSym = hb_dynsymFindName("QSSLCERTIFICATE");
      auto pArray = hb_itemArrayNew(0);
      if (pDynSym != nullptr) {
        for (const auto &item : list) {
          hb_vmPushDynSym(pDynSym);
          hb_vmPushNil();
          hb_vmDo(0);
          auto pObject = hb_itemNew(nullptr);
          hb_itemCopy(pObject, hb_stackReturnItem());
          auto pItem = hb_itemPutPtr(nullptr, new QSslCertificate(item));
          hb_objSendMsg(pObject, "_POINTER", 1, pItem);
          hb_itemRelease(pItem);
          auto pDestroy = hb_itemPutL(nullptr, true);
          hb_objSendMsg(pObject, "_SELF_DESTRUCTION", 1, pDestroy);
          hb_itemRelease(pDestroy);
          hb_arrayAddForward(pArray, pObject);
          hb_itemRelease(pObject);
        }
      } else {
        hb_errRT_BASE(EG_NOFUNC, 1001, nullptr, "QSSLCERTIFICATE", HB_ERR_ARGS_BASEPARAMS);
      }
      hb_itemReturnRelease(pArray);
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// static void addDefaultCaCertificate(const QSslCertificate &certificate)
HB_FUNC_STATIC(QSSLSOCKET_ADDDEFAULTCACERTIFICATE)
{
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  if (ISNUMPAR(1) && ISQSSLCERTIFICATE(1)) {
#endif
    QSslSocket::addDefaultCaCertificate(*PQSSLCERTIFICATE(1));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  } else {
    THROW_ERROR_3012();
  }
#endif

  RETURN_SELF();
}

HB_FUNC_STATIC(QSSLSOCKET_ADDDEFAULTCACERTIFICATES)
{
  if (ISBETWEEN(1, 3) && HB_ISCHAR(1) && ISNUMORNIL(2) && ISNUMORNIL(3)) {
    // static bool addDefaultCaCertificates(const QString &path, QSsl::EncodingFormat format = QSsl::Pem,
    // QRegExp::PatternSyntax syntax = QRegExp::FixedString)
    RBOOL(QSslSocket::addDefaultCaCertificates(PQSTRING(1), HB_ISNIL(2) ? QSsl::Pem : PQSSL_ENCODINGFORMAT(2),
                                               HB_ISNIL(3) ? QRegExp::FixedString : PQREGEXP_PATTERNSYNTAX(3)));
  } else if (ISNUMPAR(1) && HB_ISARRAY(1)) {
    // static void addDefaultCaCertificates(const QList<QSslCertificate> &certificates)
    QList<QSslCertificate> par1;
    auto aList1 = hb_param(1, HB_IT_ARRAY);
    int nLen1 = hb_arrayLen(aList1);
    for (auto i1 = 0; i1 < nLen1; i1++) {
      par1 << *static_cast<QSslCertificate *>(
          hb_itemGetPtr(hb_objSendMsg(hb_arrayGetItemPtr(aList1, i1 + 1), "POINTER", 0)));
    }
    QSslSocket::addDefaultCaCertificates(par1);
    RETURN_SELF();
  } else {
    THROW_ERROR_3012();
  }
}

// static void setDefaultCaCertificates(const QList<QSslCertificate> &certificates)
HB_FUNC_STATIC(QSSLSOCKET_SETDEFAULTCACERTIFICATES)
{
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  if (ISNUMPAR(1) && HB_ISARRAY(1)) {
#endif
    QList<QSslCertificate> par1;
    auto aList1 = hb_param(1, HB_IT_ARRAY);
    int nLen1 = hb_arrayLen(aList1);
    for (auto i1 = 0; i1 < nLen1; i1++) {
      par1 << *static_cast<QSslCertificate *>(
          hb_itemGetPtr(hb_objSendMsg(hb_arrayGetItemPtr(aList1, i1 + 1), "POINTER", 0)));
    }
    QSslSocket::setDefaultCaCertificates(par1);
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  } else {
    THROW_ERROR_3012();
  }
#endif

  RETURN_SELF();
}

// static QList<QSslCertificate> defaultCaCertificates()
HB_FUNC_STATIC(QSSLSOCKET_DEFAULTCACERTIFICATES)
{
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  if (ISNUMPAR(0)) {
#endif
    auto list = QSslSocket::defaultCaCertificates();
    auto pDynSym = hb_dynsymFindName("QSSLCERTIFICATE");
    auto pArray = hb_itemArrayNew(0);
    if (pDynSym != nullptr) {
      for (const auto &item : list) {
        hb_vmPushDynSym(pDynSym);
        hb_vmPushNil();
        hb_vmDo(0);
        auto pObject = hb_itemNew(nullptr);
        hb_itemCopy(pObject, hb_stackReturnItem());
        auto pItem = hb_itemPutPtr(nullptr, new QSslCertificate(item));
        hb_objSendMsg(pObject, "_POINTER", 1, pItem);
        hb_itemRelease(pItem);
        auto pDestroy = hb_itemPutL(nullptr, true);
        hb_objSendMsg(pObject, "_SELF_DESTRUCTION", 1, pDestroy);
        hb_itemRelease(pDestroy);
        hb_arrayAddForward(pArray, pObject);
        hb_itemRelease(pObject);
      }
    } else {
      hb_errRT_BASE(EG_NOFUNC, 1001, nullptr, "QSSLCERTIFICATE", HB_ERR_ARGS_BASEPARAMS);
    }
    hb_itemReturnRelease(pArray);
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  } else {
    THROW_ERROR_3012();
  }
#endif
}

// static QList<QSslCertificate> systemCaCertificates()
HB_FUNC_STATIC(QSSLSOCKET_SYSTEMCACERTIFICATES)
{
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  if (ISNUMPAR(0)) {
#endif
    auto list = QSslSocket::systemCaCertificates();
    auto pDynSym = hb_dynsymFindName("QSSLCERTIFICATE");
    auto pArray = hb_itemArrayNew(0);
    if (pDynSym != nullptr) {
      for (const auto &item : list) {
        hb_vmPushDynSym(pDynSym);
        hb_vmPushNil();
        hb_vmDo(0);
        auto pObject = hb_itemNew(nullptr);
        hb_itemCopy(pObject, hb_stackReturnItem());
        auto pItem = hb_itemPutPtr(nullptr, new QSslCertificate(item));
        hb_objSendMsg(pObject, "_POINTER", 1, pItem);
        hb_itemRelease(pItem);
        auto pDestroy = hb_itemPutL(nullptr, true);
        hb_objSendMsg(pObject, "_SELF_DESTRUCTION", 1, pDestroy);
        hb_itemRelease(pDestroy);
        hb_arrayAddForward(pArray, pObject);
        hb_itemRelease(pObject);
      }
    } else {
      hb_errRT_BASE(EG_NOFUNC, 1001, nullptr, "QSSLCERTIFICATE", HB_ERR_ARGS_BASEPARAMS);
    }
    hb_itemReturnRelease(pArray);
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  } else {
    THROW_ERROR_3012();
  }
#endif
}

// bool waitForConnected(int msecs = 30000) Q_DECL_OVERRIDE
HB_FUNC_STATIC(QSSLSOCKET_WAITFORCONNECTED)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISBETWEEN(0, 1) && ISNUMORNIL(1)) {
#endif
      RBOOL(obj->waitForConnected(OPINT(1, 30000)));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// bool waitForEncrypted(int msecs = 30000)
HB_FUNC_STATIC(QSSLSOCKET_WAITFORENCRYPTED)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISBETWEEN(0, 1) && ISNUMORNIL(1)) {
#endif
      RBOOL(obj->waitForEncrypted(OPINT(1, 30000)));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// bool waitForReadyRead(int msecs = 30000) Q_DECL_OVERRIDE
HB_FUNC_STATIC(QSSLSOCKET_WAITFORREADYREAD)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISBETWEEN(0, 1) && ISNUMORNIL(1)) {
#endif
      RBOOL(obj->waitForReadyRead(OPINT(1, 30000)));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// bool waitForBytesWritten(int msecs = 30000) Q_DECL_OVERRIDE
HB_FUNC_STATIC(QSSLSOCKET_WAITFORBYTESWRITTEN)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISBETWEEN(0, 1) && ISNUMORNIL(1)) {
#endif
      RBOOL(obj->waitForBytesWritten(OPINT(1, 30000)));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// bool waitForDisconnected(int msecs = 30000) Q_DECL_OVERRIDE
HB_FUNC_STATIC(QSSLSOCKET_WAITFORDISCONNECTED)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISBETWEEN(0, 1) && ISNUMORNIL(1)) {
#endif
      RBOOL(obj->waitForDisconnected(OPINT(1, 30000)));
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// QList<QSslError> sslErrors() const
HB_FUNC_STATIC(QSSLSOCKET_SSLERRORS)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      auto list = obj->sslErrors();
      auto pDynSym = hb_dynsymFindName("QSSLERROR");
      auto pArray = hb_itemArrayNew(0);
      if (pDynSym != nullptr) {
        for (const auto &item : list) {
          hb_vmPushDynSym(pDynSym);
          hb_vmPushNil();
          hb_vmDo(0);
          auto pObject = hb_itemNew(nullptr);
          hb_itemCopy(pObject, hb_stackReturnItem());
          auto pItem = hb_itemPutPtr(nullptr, new QSslError(item));
          hb_objSendMsg(pObject, "_POINTER", 1, pItem);
          hb_itemRelease(pItem);
          auto pDestroy = hb_itemPutL(nullptr, true);
          hb_objSendMsg(pObject, "_SELF_DESTRUCTION", 1, pDestroy);
          hb_itemRelease(pDestroy);
          hb_arrayAddForward(pArray, pObject);
          hb_itemRelease(pObject);
        }
      } else {
        hb_errRT_BASE(EG_NOFUNC, 1001, nullptr, "QSSLERROR", HB_ERR_ARGS_BASEPARAMS);
      }
      hb_itemReturnRelease(pArray);
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }
}

// static bool supportsSsl()
HB_FUNC_STATIC(QSSLSOCKET_SUPPORTSSSL)
{
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  if (ISNUMPAR(0)) {
#endif
    RBOOL(QSslSocket::supportsSsl());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  } else {
    THROW_ERROR_3012();
  }
#endif
}

// static long sslLibraryVersionNumber()
HB_FUNC_STATIC(QSSLSOCKET_SSLLIBRARYVERSIONNUMBER)
{
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  if (ISNUMPAR(0)) {
#endif
    RLONG(QSslSocket::sslLibraryVersionNumber());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  } else {
    THROW_ERROR_3012();
  }
#endif
}

// static QString sslLibraryVersionString()
HB_FUNC_STATIC(QSSLSOCKET_SSLLIBRARYVERSIONSTRING)
{
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  if (ISNUMPAR(0)) {
#endif
    RQSTRING(QSslSocket::sslLibraryVersionString());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  } else {
    THROW_ERROR_3012();
  }
#endif
}

// static long sslLibraryBuildVersionNumber()
HB_FUNC_STATIC(QSSLSOCKET_SSLLIBRARYBUILDVERSIONNUMBER)
{
#if (QT_VERSION >= QT_VERSION_CHECK(5, 4, 0))
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  if (ISNUMPAR(0)) {
#endif
    RLONG(QSslSocket::sslLibraryBuildVersionNumber());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  } else {
    THROW_ERROR_3012();
  }
#endif
#endif
}

// static QString sslLibraryBuildVersionString()
HB_FUNC_STATIC(QSSLSOCKET_SSLLIBRARYBUILDVERSIONSTRING)
{
#if (QT_VERSION >= QT_VERSION_CHECK(5, 4, 0))
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  if (ISNUMPAR(0)) {
#endif
    RQSTRING(QSslSocket::sslLibraryBuildVersionString());
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
  } else {
    THROW_ERROR_3012();
  }
#endif
#endif
}

HB_FUNC_STATIC(QSSLSOCKET_IGNORESSLERRORS)
{
  if (ISNUMPAR(1) && HB_ISARRAY(1)) {
    // void ignoreSslErrors(const QList<QSslError> &errors)
    GET_PTR_FROM_SELF(obj);

    if (obj != nullptr) {
      QList<QSslError> par1;
      auto aList1 = hb_param(1, HB_IT_ARRAY);
      int nLen1 = hb_arrayLen(aList1);
      for (auto i1 = 0; i1 < nLen1; i1++) {
        par1 << *static_cast<QSslError *>(
            hb_itemGetPtr(hb_objSendMsg(hb_arrayGetItemPtr(aList1, i1 + 1), "POINTER", 0)));
      }
      obj->ignoreSslErrors(par1);
    }

    RETURN_SELF();
  } else if (ISNUMPAR(0)) {
    // void ignoreSslErrors()
    GET_PTR_FROM_SELF(obj);

    if (obj != nullptr) {
      obj->ignoreSslErrors();
    }

    RETURN_SELF();
  } else {
    THROW_ERROR_3012();
  }
}

// void startClientEncryption()
HB_FUNC_STATIC(QSSLSOCKET_STARTCLIENTENCRYPTION)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      obj->startClientEncryption();
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// void startServerEncryption()
HB_FUNC_STATIC(QSSLSOCKET_STARTSERVERENCRYPTION)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != nullptr) {
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      obj->startServerEncryption();
#ifndef QT5XHB_DONT_CHECK_PARAMETERS
    } else {
      THROW_ERROR_3012();
    }
#endif
  }

  RETURN_SELF();
}

// void encrypted()
HB_FUNC_STATIC(QSSLSOCKET_ONENCRYPTED)
{
  GET_PTR_FROM_SELF(sender);

  auto result = false;

  if (sender != nullptr) {
    auto indexOfSignal = sender->metaObject()->indexOfSignal("encrypted()");
    auto indexOfCodeBlock = -1;

    if (ISNUMPAR(1) && ISBLOCKORSYMBOL(1)) {
      if (Qt5xHb::Signals_connection(sender, indexOfSignal, indexOfCodeBlock)) {
        auto connection = QObject::connect(sender, &QSslSocket::encrypted, [sender, indexOfCodeBlock]() {
          auto cb = Qt5xHb::Signals_return_codeblock(indexOfCodeBlock);

          if (cb != nullptr) {
            auto pSender = Qt5xHb::Signals_return_qobject(sender, "QSSLSOCKET");
            hb_vmEvalBlockV(cb, 1, pSender);
            hb_itemRelease(pSender);
          }
        });
        Qt5xHb::Signals_store_connection(indexOfCodeBlock, connection);
        result = true;
      }
    } else if (ISNUMPAR(0)) {
      Qt5xHb::Signals_disconnection(sender, indexOfSignal);
      QObject::disconnect(Qt5xHb::Signals_get_connection(sender, indexOfSignal));
      result = true;
    } else {
      THROW_ERROR_3012();
    }
  }

  hb_retl(result);
}

// void encryptedBytesWritten(qint64 written)
HB_FUNC_STATIC(QSSLSOCKET_ONENCRYPTEDBYTESWRITTEN)
{
  GET_PTR_FROM_SELF(sender);

  auto result = false;

  if (sender != nullptr) {
    auto indexOfSignal = sender->metaObject()->indexOfSignal("encryptedBytesWritten(qint64)");
    auto indexOfCodeBlock = -1;

    if (ISNUMPAR(1) && ISBLOCKORSYMBOL(1)) {
      if (Qt5xHb::Signals_connection(sender, indexOfSignal, indexOfCodeBlock)) {
        auto connection =
            QObject::connect(sender, &QSslSocket::encryptedBytesWritten, [sender, indexOfCodeBlock](qint64 arg1) {
              auto cb = Qt5xHb::Signals_return_codeblock(indexOfCodeBlock);

              if (cb != nullptr) {
                auto pSender = Qt5xHb::Signals_return_qobject(sender, "QSSLSOCKET");
                auto pArg1 = hb_itemPutNLL(nullptr, arg1);
                hb_vmEvalBlockV(cb, 2, pSender, pArg1);
                hb_itemRelease(pSender);
                hb_itemRelease(pArg1);
              }
            });
        Qt5xHb::Signals_store_connection(indexOfCodeBlock, connection);
        result = true;
      }
    } else if (ISNUMPAR(0)) {
      Qt5xHb::Signals_disconnection(sender, indexOfSignal);
      QObject::disconnect(Qt5xHb::Signals_get_connection(sender, indexOfSignal));
      result = true;
    } else {
      THROW_ERROR_3012();
    }
  }

  hb_retl(result);
}

// void modeChanged(QSslSocket::SslMode mode)
HB_FUNC_STATIC(QSSLSOCKET_ONMODECHANGED)
{
  GET_PTR_FROM_SELF(sender);

  auto result = false;

  if (sender != nullptr) {
    auto indexOfSignal = sender->metaObject()->indexOfSignal("modeChanged(QSslSocket::SslMode)");
    auto indexOfCodeBlock = -1;

    if (ISNUMPAR(1) && ISBLOCKORSYMBOL(1)) {
      if (Qt5xHb::Signals_connection(sender, indexOfSignal, indexOfCodeBlock)) {
        auto connection =
            QObject::connect(sender, &QSslSocket::modeChanged, [sender, indexOfCodeBlock](QSslSocket::SslMode arg1) {
              auto cb = Qt5xHb::Signals_return_codeblock(indexOfCodeBlock);

              if (cb != nullptr) {
                auto pSender = Qt5xHb::Signals_return_qobject(sender, "QSSLSOCKET");
                auto pArg1 = hb_itemPutNI(nullptr, static_cast<int>(arg1));
                hb_vmEvalBlockV(cb, 2, pSender, pArg1);
                hb_itemRelease(pSender);
                hb_itemRelease(pArg1);
              }
            });
        Qt5xHb::Signals_store_connection(indexOfCodeBlock, connection);
        result = true;
      }
    } else if (ISNUMPAR(0)) {
      Qt5xHb::Signals_disconnection(sender, indexOfSignal);
      QObject::disconnect(Qt5xHb::Signals_get_connection(sender, indexOfSignal));
      result = true;
    } else {
      THROW_ERROR_3012();
    }
  }

  hb_retl(result);
}

// void peerVerifyError(const QSslError &error)
HB_FUNC_STATIC(QSSLSOCKET_ONPEERVERIFYERROR)
{
  GET_PTR_FROM_SELF(sender);

  auto result = false;

  if (sender != nullptr) {
    auto indexOfSignal = sender->metaObject()->indexOfSignal("peerVerifyError(QSslError)");
    auto indexOfCodeBlock = -1;

    if (ISNUMPAR(1) && ISBLOCKORSYMBOL(1)) {
      if (Qt5xHb::Signals_connection(sender, indexOfSignal, indexOfCodeBlock)) {
        auto connection =
            QObject::connect(sender, &QSslSocket::peerVerifyError, [sender, indexOfCodeBlock](const QSslError &arg1) {
              auto cb = Qt5xHb::Signals_return_codeblock(indexOfCodeBlock);

              if (cb != nullptr) {
                auto pSender = Qt5xHb::Signals_return_qobject(sender, "QSSLSOCKET");
                auto pArg1 = Qt5xHb::Signals_return_object((void *)&arg1, "QSSLERROR");
                hb_vmEvalBlockV(cb, 2, pSender, pArg1);
                hb_itemRelease(pSender);
                hb_itemRelease(pArg1);
              }
            });
        Qt5xHb::Signals_store_connection(indexOfCodeBlock, connection);
        result = true;
      }
    } else if (ISNUMPAR(0)) {
      Qt5xHb::Signals_disconnection(sender, indexOfSignal);
      QObject::disconnect(Qt5xHb::Signals_get_connection(sender, indexOfSignal));
      result = true;
    } else {
      THROW_ERROR_3012();
    }
  }

  hb_retl(result);
}

// void preSharedKeyAuthenticationRequired(QSslPreSharedKeyAuthenticator *authenticator)
HB_FUNC_STATIC(QSSLSOCKET_ONPRESHAREDKEYAUTHENTICATIONREQUIRED)
{
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
  GET_PTR_FROM_SELF(sender);

  auto result = false;

  if (sender != nullptr) {
    auto indexOfSignal =
        sender->metaObject()->indexOfSignal("preSharedKeyAuthenticationRequired(QSslPreSharedKeyAuthenticator*)");
    auto indexOfCodeBlock = -1;

    if (ISNUMPAR(1) && ISBLOCKORSYMBOL(1)) {
      if (Qt5xHb::Signals_connection(sender, indexOfSignal, indexOfCodeBlock)) {
        auto connection = QObject::connect(sender, &QSslSocket::preSharedKeyAuthenticationRequired,
                                           [sender, indexOfCodeBlock](QSslPreSharedKeyAuthenticator *arg1) {
                                             auto cb = Qt5xHb::Signals_return_codeblock(indexOfCodeBlock);

                                             if (cb != nullptr) {
                                               auto pSender = Qt5xHb::Signals_return_qobject(sender, "QSSLSOCKET");
                                               auto pArg1 = Qt5xHb::Signals_return_object(
                                                   (void *)arg1, "QSSLPRESHAREDKEYAUTHENTICATOR");
                                               hb_vmEvalBlockV(cb, 2, pSender, pArg1);
                                               hb_itemRelease(pSender);
                                               hb_itemRelease(pArg1);
                                             }
                                           });
        Qt5xHb::Signals_store_connection(indexOfCodeBlock, connection);
        result = true;
      }
    } else if (ISNUMPAR(0)) {
      Qt5xHb::Signals_disconnection(sender, indexOfSignal);
      QObject::disconnect(Qt5xHb::Signals_get_connection(sender, indexOfSignal));
      result = true;
    } else {
      THROW_ERROR_3012();
    }
  }

  hb_retl(result);
#else
  hb_retl(false);
#endif
}

// void sslErrors(const QList<QSslError> &errors)
HB_FUNC_STATIC(QSSLSOCKET_ONSSLERRORS)
{
  GET_PTR_FROM_SELF(sender);

  auto result = false;

  if (sender != nullptr) {
    auto indexOfSignal = sender->metaObject()->indexOfSignal("sslErrors(QList<QSslError>)");
    auto indexOfCodeBlock = -1;

    if (ISNUMPAR(1) && ISBLOCKORSYMBOL(1)) {
      if (Qt5xHb::Signals_connection(sender, indexOfSignal, indexOfCodeBlock)) {
        auto connection =
            QObject::connect(sender, QOverload<const QList<QSslError> &>::of(&QSslSocket::sslErrors),
                             [sender, indexOfCodeBlock](const QList<QSslError> &arg1) {
                               auto cb = Qt5xHb::Signals_return_codeblock(indexOfCodeBlock);

                               if (cb != nullptr) {
                                 auto pSender = Qt5xHb::Signals_return_qobject(sender, "QSSLSOCKET");
                                 auto pDynSym = hb_dynsymFindName("QSSLERROR");
                                 auto pArg1 = hb_itemArrayNew(0);
                                 if (pDynSym != nullptr) {
                                   for (auto i = 0; i < arg1.count(); i++) {
                                     hb_vmPushDynSym(pDynSym);
                                     hb_vmPushNil();
                                     hb_vmDo(0);
                                     auto pTempObject = hb_itemNew(nullptr);
                                     hb_itemCopy(pTempObject, hb_stackReturnItem());
                                     auto pTempItem = hb_itemNew(nullptr);
                                     hb_itemPutPtr(pTempItem, new QSslError(arg1[i]));
                                     hb_objSendMsg(pTempObject, "NEWFROMPOINTER", 1, pTempItem);
                                     hb_arrayAddForward(pArg1, pTempObject);
                                     hb_itemRelease(pTempObject);
                                     hb_itemRelease(pTempItem);
                                   }
                                 } else {
                                   hb_errRT_BASE(EG_NOFUNC, 1001, nullptr, "QSSLERROR", HB_ERR_ARGS_BASEPARAMS);
                                 }
                                 hb_vmEvalBlockV(cb, 2, pSender, pArg1);
                                 hb_itemRelease(pSender);
                                 hb_itemRelease(pArg1);
                               }
                             });
        Qt5xHb::Signals_store_connection(indexOfCodeBlock, connection);
        result = true;
      }
    } else if (ISNUMPAR(0)) {
      Qt5xHb::Signals_disconnection(sender, indexOfSignal);
      QObject::disconnect(Qt5xHb::Signals_get_connection(sender, indexOfSignal));
      result = true;
    } else {
      THROW_ERROR_3012();
    }
  }

  hb_retl(result);
}

#pragma ENDDUMP
